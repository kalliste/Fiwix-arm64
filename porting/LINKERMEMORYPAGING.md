# Linker, Memory Layout, and Paging Constraints (x86 Baseline)

## Linker Script Assumptions
- The kernel image is currently linked as `elf32-i386` with the architecture explicitly set to i386, anchoring the build to 32-bit x86 output. The entry point is `_start`, the virtual base address is assigned from `PAGE_OFFSET`, and the physical load address is fixed at `KERNEL_ADDR` (1 MB).【F:fiwix.ld†L10-L34】
- Section placement relies on a 1 MB physical origin and a high virtual offset: `.setup` is aligned to 4 KB at the physical base, after which the location counter is bumped by the virtual offset before emitting `.text`, `.data`, and `.bss`. Each runtime virtual address is mapped back to its physical counterpart via `AT(ADDR(...) - vaddr)` expressions, assuming a simple subtraction is valid for all sections.【F:fiwix.ld†L19-L50】
- `PAGE_OFFSET` and `KERNEL_ADDR` come from `include/fiwix/linker.h`, which hard-codes two split options (3 GB user / 1 GB kernel by default, or 2 GB / 2 GB when `CONFIG_VM_SPLIT22` is set). The header also defines a 4 KB kernel stack and a `GDT_BASE` that depends on a 32-bit `0xFFFFFFFF` top-of-address-space constant.【F:include/fiwix/linker.h†L13-L21】 These definitions will all need Arm64 equivalents.

## Documented Kernel Memory Layout
- The `kmem_layout` diagram documents that the kernel binary (text/data/bss) is loaded starting at physical 1 MB, followed by the optional initrd supplied by the bootloader. Above that, contiguous regions are preallocated for the boot-time page directory/table, process and filesystem hash tables, RAM disks, and other kernel data structures. The layout explicitly references a single 4 KB temporary page directory at 0x00050000 and a 4 KB kernel stack at 0x00010000—both x86-centric expectations.【F:docs/kmem_layout.txt†L4-L55】

## Paging Setup Constraints
- Paging management assumes 32-bit page directories and tables sized with `unsigned int` entries, with helper macros like `GET_PGDIR`/`GET_PGTBL` targeting 4 KB pages. `map_kaddr()` allocates new page tables in 4 KB chunks, zeroes them via high-memory aliases (`paddr + PAGE_OFFSET`), and stores linear addresses directly in the page table entries, reflecting the x86-style 4 KB PTE format.【F:mm/memory.c†L24-L67】
- `setup_tmp_pgdir()` expects Multiboot-provided memory information, caps physical memory based on the current virtual split, and builds identity-mapped page tables at the top of detected RAM. It mirrors each page table into both the low mappings and the kernel's `PAGE_OFFSET` region while adding `GDT_BASE` offsets—again reflecting 32-bit segmentation and dual-mapping assumptions.【F:mm/memory.c†L81-L123】 These behaviors will need redesign for Arm64's translation tables, different memory map sources (UEFI/DT/PSCI), and lack of segmentation.
